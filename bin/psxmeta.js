// Generated by Haxe 4.1.5
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
var djNode_BaseApp = function() {
	this.argsAction = null;
	this.argsOptions = { };
	this.argsOutput = null;
	this.argsInput = [];
	this.ARGS = { inputRule : "no", outputRule : "no", requireAction : false, supportWildcards : true, helpInput : null, helpOutput : null, helpText : null, Actions : [], Options : []};
	this.PROGRAM_INFO = { name : "CLI Application", version : "0.1"};
	this.HELP_MARGIN = 16;
	var _gthis = this;
	djNode_BaseApp.app = this;
	djNode_tools_LOG.init();
	this.set_FLAG_USE_SLASH_FOR_OPTION(false);
	this.T = djNode_BaseApp.TERMINAL = new djNode_Terminal();
	process.once("exit",$bind(this,this.onExit));
	process.once("SIGINT",function() {
		process.exit(1223);
	});
	process.once("uncaughtException",function(err) {
		var e = " Critical Error :: ";
		if(((err) instanceof Error)) {
			e += Std.string(err.message);
		} else {
			e += err;
		}
		_gthis.exitError(e);
	});
	try {
		this.init();
	} catch( _g ) {
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(typeof(_g1) == "string") {
			var e = _g1;
			this.printBanner(true);
			if(e == "HELP") {
				this.printHelp();
				process.exit(0);
			}
			this.exitError(e,true);
		} else {
			throw _g;
		}
	}
	djNode_tools_LOG.log("- Inputs : " + this.argsInput.join(", "));
	djNode_tools_LOG.log("- Output : " + this.argsOutput);
	djNode_tools_LOG.log("- Action  set : " + this.argsAction);
	djNode_tools_LOG.log("- Options set : ");
	var _g = 0;
	var _g1 = Reflect.fields(this.argsOptions);
	while(_g < _g1.length) {
		var o = _g1[_g];
		++_g;
		djNode_tools_LOG.log("\t\t" + o + " : " + Std.string(Reflect.getProperty(this.argsOptions,o)));
	}
	djNode_tools_LOG.log(djA_StrT.rep(40,"─"));
	process.nextTick($bind(this,this.onStart));
};
djNode_BaseApp.__name__ = true;
djNode_BaseApp.prototype = {
	set_FLAG_USE_SLASH_FOR_OPTION: function(v) {
		this.FLAG_USE_SLASH_FOR_OPTION = v;
		if(v) {
			this._sb = ["/","?"];
		} else {
			this._sb = ["-","help"];
		}
		return v;
	}
	,init: function() {
		var _this = this.T;
		process.stdout.write("\x1B[0m");
		this.ARGS.Options.unshift(["o","-output","yes"]);
		var P = this.PROGRAM_INFO;
		var A = this.ARGS;
		if(P.executable == null) {
			P.executable = js_node_Path.basename(__filename);
		}
		djNode_tools_LOG.log("Creating Application [ " + P.name + " ,v" + P.version + " ]");
		var cc = 0;
		var $arguments = process.argv.slice(2);
		var arg;
		while(true) {
			arg = $arguments[cc++];
			if(!(arg != null)) {
				break;
			}
			if(arg.charAt(0) == this._sb[0]) {
				if(arg.toLowerCase().indexOf(this._sb[1]) == 1) {
					throw haxe_Exception.thrown("HELP");
				}
				var o = this.getArgOption(HxOverrides.substr(arg,1,null));
				if(o == null) {
					throw haxe_Exception.thrown("Illegal argument [" + arg + "]");
				}
				if(o[2] != null) {
					var nextArg = $arguments[cc++];
					if(nextArg == null || this.getArgOption(nextArg) != null) {
						throw haxe_Exception.thrown("Argument [" + arg + "] requires a parameter");
					}
					this.argsOptions[o[0]] = nextArg;
				} else {
					this.argsOptions[o[0]] = true;
				}
				continue;
			}
			var a = this.getArgAction(arg);
			if(a != null) {
				if(this.argsAction == null) {
					this.argsAction = a[0];
					continue;
				}
			}
			this.argsInput.push(arg);
		}
		if(this.argsOptions.o != null) {
			this.argsOutput = this.argsOptions.o;
		}
		var _g = 0;
		var _g1 = this.argsInput;
		while(_g < _g1.length) {
			var i = _g1[_g];
			++_g;
			if(i.indexOf("*") >= 0) {
				if(this.argsInput.length > 1) {
					throw haxe_Exception.thrown("Multiple Inputs with wildcards are not supported");
				}
				this.argsInput = djNode_tools_FileTool.getFileListFromWildcard(i);
				if(this.argsInput.length == 0) {
					throw haxe_Exception.thrown("Wildcard `" + i + "` returned 0 files");
				}
				break;
			}
		}
		if(this.argsAction == null && this.argsInput.length > 0) {
			var act = this.getArgAction(null,HxOverrides.substr(js_node_Path.extname(this.argsInput[0].toLowerCase()),1,null));
			if(act != null) {
				this.argsAction = act[0];
			}
		}
		if(this.argsInput.length == 0 && ["yes","multi"].indexOf(A.inputRule) >= 0) {
			throw haxe_Exception.thrown("Input is required");
		}
		if(this.argsOutput == null && A.outputRule == "yes") {
			throw haxe_Exception.thrown("Output is required");
		}
		if(A.requireAction && this.argsAction == null) {
			throw haxe_Exception.thrown("Setting an action is required");
		}
		var _g = 0;
		var _g1 = this.ARGS.Options;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o[2] == null) {
				if(!Object.prototype.hasOwnProperty.call(this.argsOptions,o[0])) {
					this.argsOptions[o[0]] = false;
				}
			}
		}
	}
	,onStart: function() {
	}
	,onExit: function(code) {
		if(this.onExit_ != null) {
			this.onExit_(code);
		}
		djNode_tools_LOG.log("==> [EXIT] with code " + code);
		djNode_tools_LOG.end();
		var _this = this.T;
		process.stdout.write("\x1B[0m");
		this.T.cursorShow();
	}
	,printHelp: function() {
		var _gthis = this;
		var A = this.ARGS;
		var P = this.PROGRAM_INFO;
		var sp = function(s) {
			return djA_StrT.rep(s," ");
		};
		var __fixDescFormat = function(s,b) {
			var S;
			if(djA_StrT.isEmpty(s)) {
				S = "...";
			} else {
				var _this_r = new RegExp("(\n)","g".split("u").join(""));
				var by = "\n " + sp(_gthis.HELP_MARGIN);
				S = s.replace(_this_r,by);
			}
			var g = S.split("\n");
			g[0] += b;
			return g.join("\n");
		};
		this.T.ptag("<green> Program Usage:\n");
		var s = "   " + P.executable + " ";
		if(A.Actions.length > 0) {
			s += "<action> ";
		}
		if(A.Options.length > 1) {
			s += "[<options>...] ";
		}
		if(A.inputRule != "no") {
			s += A.inputRule == "multi" ? "[<inputs>...] " : "<input> ";
		}
		if(A.outputRule != "no") {
			s += this._sb[0] + "o <output> ";
		}
		var _this = this.T.ptag("<bold,white>" + s + "<!>\n").fg(djNode_TColor.darkgray);
		var str = djA_StrT.rep(40,"─");
		process.stdout.write(str + "\n");
		var _prtIO = function(r,lab,txt) {
			if(r == "no") {
				return false;
			}
			_gthis.T.ptag("<yellow> [" + lab + "] <!> is " + (r == "opt" ? "optional." : "required."));
			if(r == "multi") {
				_gthis.T.ptag("<darkgray> (multiple supported)");
			}
			var _this = _gthis.T;
			process.stdout.write("\n");
			if(txt != null) {
				var _this_r = new RegExp("(\n)","g".split("u").join(""));
				txt = "<gray>\t " + txt.replace(_this_r,"\n\t ");
				var _this = _gthis.T.ptag(txt);
				process.stdout.write("\n");
			}
			return true;
		};
		var a = _prtIO(A.inputRule,"input",A.helpInput);
		var b = _prtIO(A.outputRule,"output",A.helpOutput);
		if(a || b) {
			var _this = this.T.ptag(" <darkgray>" + djA_StrT.rep(40,"─"));
			process.stdout.write("\n");
		}
		var _this = this.T;
		process.stdout.write("\x1B[0m");
		if(A.Actions.length > 0) {
			this.T.ptag("<magenta> [actions] ");
			this.T.ptag("<darkmagenta>(you can set one action at a time)<!>\n");
			var _g = 0;
			var _g1 = A.Actions;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i[1].charAt(0) == "-") {
					continue;
				}
				i[1] = __fixDescFormat(i[1],i[2] == null ? "" : "<darkgray> | auto ext:[" + i[2] + "] <!>");
				this.T.fg(djNode_TColor.white).bold();
				var _this = this.T.ptag(" " + i[0] + sp(this.HELP_MARGIN - i[0].length));
				process.stdout.write("\x1B[0m");
				_this.ptag(i[1]);
				var _this1 = this.T;
				process.stdout.write("\n");
			}
		}
		if(A.Options.length > 1) {
			this.T.ptag("<cyan> [options] ");
			this.T.ptag("<darkcyan>(you can set multiple options)<!>\n");
			var _g = 0;
			var _g1 = A.Options;
			while(_g < _g1.length) {
				var i = _g1[_g];
				++_g;
				if(i[1].charAt(0) == "-") {
					continue;
				}
				i[1] = __fixDescFormat(i[1],i[2] == null ? "" : "<darkgray> (requires parameter) <!>");
				this.T.fg(djNode_TColor.white).bold();
				var _this = this.T.ptag(" " + this._sb[0] + i[0] + sp(this.HELP_MARGIN - i[0].length - 1));
				process.stdout.write("\x1B[0m");
				_this.ptag(i[1]);
				var _this1 = this.T;
				process.stdout.write("\n");
			}
		}
		if(this.ARGS.helpText != null) {
			var _this = this.T;
			process.stdout.write("\n");
			this.T.ptag("" + this.ARGS.helpText + "\n");
		}
	}
	,printBanner: function(longer) {
		if(longer == null) {
			longer = false;
		}
		var P = this.PROGRAM_INFO;
		var col = "cyan";
		var _this = this.T;
		process.stdout.write("\n");
		this.T.ptag("<:" + col + ",black>==<!><" + col + ",bold> " + P.name + " <darkgray>v" + P.version + "<!>");
		if(longer) {
			if(P.author != null) {
				this.T.ptag(" by " + P.author);
			}
			var _this = this.T;
			process.stdout.write("\n");
			if(P.info != null) {
				this.T.ptag(" - " + P.info + "\n");
			}
			if(P.desc != null) {
				this.T.ptag(" - " + P.desc + "\n");
			}
		} else {
			var _this = this.T;
			process.stdout.write("\n");
		}
		this.T.ptag("<" + Std.string(djNode_TColor.darkgray) + ">" + djA_StrT.rep(40,"─") + "<!>\n");
	}
	,getArgOption: function(tag) {
		var _g = 0;
		var _g1 = this.ARGS.Options;
		while(_g < _g1.length) {
			var o = _g1[_g];
			++_g;
			if(o[0] == tag) {
				return o;
			}
		}
		return null;
	}
	,getArgAction: function(tag,ext) {
		var _g = 0;
		var _g1 = this.ARGS.Actions;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(tag != null && a[0] == tag) {
				return a;
			}
			if(ext != null && a[2] != null) {
				if(a[2].split(",").indexOf(ext.toLowerCase()) >= 0) {
					return a;
				}
			}
		}
		return null;
	}
	,exitError: function(text,showHelp) {
		if(showHelp == null) {
			showHelp = false;
		}
		this.T.ptag("\n<:darkred,white> ERROR <!> " + text + "<!>\n");
		if(showHelp) {
			this.T.ptag("<darkgray>" + djA_StrT.rep(40,"─") + ("\n<yellow> " + this._sb[0] + this._sb[1] + " <!> for usage info\n"));
		}
		djNode_tools_LOG.FLAG_STDOUT = false;
		djNode_tools_LOG.log(this.T.PARSED_NOTAG,4);
		process.exit(1);
	}
	,isAdmin: function() {
		var res = djNode_utils_CLIApp.quickExecS("fsutil dirty query %systemdrive% >nul");
		return res != null;
	}
	,autoCallAction: function() {
		var fn = Reflect.field(this,"action_" + this.argsAction);
		if(fn != null && Reflect.isFunction(fn)) {
			return fn.apply(this,[]);
		}
		return null;
	}
	,waitKeyQuit: function() {
		this.T.ptag("\n<darkgray>Press any key to quit.<!>\n");
		djNode_Keyboard.startCapture(true,function(e) {
			process.exit(0);
		});
	}
	,getAppPathJoin: function(p) {
		return js_node_Path.join(__dirname,p);
	}
	,__properties__: {set_FLAG_USE_SLASH_FOR_OPTION:"set_FLAG_USE_SLASH_FOR_OPTION"}
};
var Main = function() {
	djNode_BaseApp.call(this);
};
Main.__name__ = true;
Main.main = function() {
	new Main();
};
Main.__super__ = djNode_BaseApp;
Main.prototype = $extend(djNode_BaseApp.prototype,{
	init: function() {
		djNode_tools_LOG.pipeTrace();
		this.PROGRAM_INFO = { name : "PSX CD Metadata", desc : "Get Playstation 1 Disc Metadatas", version : "0.1"};
		this.ARGS.outputRule = "opt";
		this.ARGS.helpOutput = "Will produce a file e.g. -o result.txt";
		this.ARGS.inputRule = "yes";
		this.ARGS.helpInput = "File or Folder.";
		this.ARGS.Options = [["d","If input is a folder, deepscan it for files"],["zip","Will also process .ZIP files. <yellow>! Requires Pismo Mount to be installed !<!>"]];
		this.ARGS.helpText = " <magenta>Example<!>\n" + "     - Get infos from all .zip and .bin games and create a text file :: \n" + "       node app c:\\roms\\ps1 -d -zip -o c:\\roms\\ps1report.txt";
		djNode_BaseApp.prototype.init.call(this);
	}
	,onStart: function() {
		var _gthis = this;
		var P = new djNode_utils_Print2(1);
		var input = this.argsInput[0];
		var OUT = [];
		if(!js_node_Fs.existsSync(input)) {
			this.exitError("Input:\"" + input + "\" does not exist");
		}
		var isDir = js_node_Fs.statSync(this.argsInput[0]).isDirectory();
		var deepScan = this.argsOptions.d;
		var usepismo = this.argsOptions.zip;
		var EXTENSIONS = Main.EXT_0.slice();
		if(usepismo) {
			if(!djNode_utils_CLIApp.checkRun("pfm.exe")) {
				this.exitError("PISMO MOUNT is not installed OR <yellow>\"pfm.exe\"<!> is not on path.");
			}
			EXTENSIONS = EXTENSIONS.concat(Main.EXT_1);
		}
		P.br().H("PSX METADATA");
		P.ptem("Input  : <yellow>{1}<!>" + (isDir ? deepScan ? " <darkgray>(deepscan)<!>" : "" : ""),this.argsInput[0]);
		if(this.argsOutput != null) {
			P.ptem("Output : <cyan>{1}<!>",this.argsOutput);
			if(js_node_Fs.existsSync(this.argsOutput)) {
				this.exitError("Output:\"" + this.argsOutput + "\" already exists");
			}
			OUT = P.buffer.slice();
			OUT.push(djA_StrT.rep(40,"-"));
		}
		var FILES = [];
		if(isDir) {
			FILES = djNode_tools_FileTool.getFiles(input,deepScan,EXTENSIONS);
			if(FILES.length == 0) {
				P.p(">> <yellow>Directory returned 0 files<!>");
				process.exit(1);
			}
		} else {
			if(EXTENSIONS.indexOf(djNode_tools_FileTool.getFileExt(input)) < 0) {
				P.p(">> <yellow>File not valid extension<!>");
				process.exit(1);
			}
			FILES.push(input);
		}
		var ax = new djA_ArrayExecSync(FILES);
		ax.onItem = function(file) {
			var fileno = "(" + (ax.C + 1) + "/" + FILES.length + ")";
			P.ptem(">> <yellow>{1}<!> File : <cyan>{2}<!> ",fileno,file);
			PSXCD.parseMulti(file,function(data) {
				if(data == null) {
					P.ptem("   <red>ERROR<!> {1}",PSXCD.ERROR);
					OUT.push(file + "|" + "ERROR : " + PSXCD.ERROR);
					ax.next();
				} else {
					P.ptem("   CD Date : <green>{1}<!> Label : {2}",data.date,data.label);
					OUT.push(js_node_Path.relative(input,file) + "|" + data.date + "|" + data.label + "|" + data.publisher);
					global.setTimeout($bind(ax,ax.next),1);
				}
			});
		};
		var writeOut = function() {
			if(_gthis.argsOutput != null) {
				P.ptem("Writing data to file <yellow>\"{1}\"<!>",_gthis.argsOutput);
				try {
					js_node_Fs.writeFileSync(_gthis.argsOutput,OUT.join("\n"));
					P.p("<green>[OK]<!>");
				} catch( _g ) {
					P.p("<red>ERROR<!> Could not write file? Do you have write access? Free space?");
				}
			}
		};
		ax.onComplete = function() {
			P.line().H("ALL DONE").br();
			writeOut();
		};
		this.onExit_ = function(c) {
			if(c > 0) {
				P.p("<yellow> Early Exit. <!>");
				writeOut();
			}
		};
		P.line();
		ax.start();
	}
});
Math.__name__ = true;
var PSXCD = function() { };
PSXCD.__name__ = true;
PSXCD.parseMulti = function(path,callback) {
	var qErr = function(s) {
		PSXCD.ERROR = s;
		callback(null);
	};
	var ext = js_node_Path.extname(path).toLowerCase();
	var BINFILE = null;
	var mounted = false;
	if([".zip",".cfs",".pfo"].indexOf(ext) >= 0) {
		var newp = djNode_app_PismoMount.mount(path);
		if(newp == null) {
			qErr("Cannot mount archive");
			return;
		}
		mounted = true;
		var files = djNode_tools_FileTool.getFiles(newp,false,[".bin"]);
		if(files.length == 0) {
			djNode_app_PismoMount.unmount(path);
			qErr("Did not find any BIN files in archive");
			return;
		}
		BINFILE = files[0];
	} else if(ext == ".bin") {
		BINFILE = path;
	} else {
		qErr("Unsupported extension \"" + ext + "\"");
		return;
	}
	PSXCD.parseBin(BINFILE,function(data) {
		if(mounted) {
			djNode_app_PismoMount.unmount(path);
		}
		if(data == null) {
			qErr("Cannot read .BIN file");
			return;
		}
		callback(data);
	});
};
PSXCD.parseBin = function(file,callback) {
	js_node_Fs.open(file,"r",function(er,fd) {
		var read = function(start,len) {
			var b = js_node_buffer_Buffer.alloc(len);
			js_node_Fs.readSync(fd,b,0,len,start);
			return b.toString();
		};
		if(er != null) {
			callback(null);
			return;
		}
		var date0 = read(38469,8);
		var o = { label : StringTools.rtrim(read(37696,32)), publisher : StringTools.rtrim(read(37974,128)), date : HxOverrides.substr(date0,0,4) + "-" + HxOverrides.substr(date0,4,2) + "-" + HxOverrides.substr(date0,-2,null)};
		js_node_Fs.closeSync(fd);
		callback(o);
	});
};
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var Type = function() { };
Type.__name__ = true;
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var ctorName = enm.__constructs__[e._hx_index];
	var params = enm[ctorName].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var djA_ArrayExecSync = function(ar) {
	this.items = ar;
};
djA_ArrayExecSync.__name__ = true;
djA_ArrayExecSync.prototype = {
	start: function(ONITEM,ONCOMPLETE) {
		this.C = -1;
		if(ONITEM != null) {
			this.onItem = ONITEM;
		}
		if(ONCOMPLETE != null) {
			this.onComplete = ONCOMPLETE;
		}
		this.next();
	}
	,next: function() {
		if(++this.C < this.items.length) {
			this.onItem(this.items[this.C]);
			return;
		} else if(this.onComplete != null) {
			this.onComplete();
			return;
		}
	}
};
var djA_StrT = function() { };
djA_StrT.__name__ = true;
djA_StrT.isEmpty = function(str) {
	if(str != null) {
		return str.length == 0;
	} else {
		return true;
	}
};
djA_StrT.rep = function(len,symbol) {
	return StringTools.lpad("",symbol,len);
};
djA_StrT.padString = function(str,length,align,char) {
	if(char == null) {
		char = " ";
	}
	if(align == null) {
		align = "l";
	}
	var b = length - str.length;
	if(b == 0) {
		return str;
	}
	if(b < 0) {
		return str.substring(0,length - 1) + djA_StrT.OVERFLOW_SMBL;
	}
	switch(align) {
	case "c":
		var _l = Math.ceil(b / 2);
		var _r = Math.floor(b / 2);
		str = StringTools.rpad("",char,_l) + str + StringTools.rpad("",char,_r);
		break;
	case "r":
		str = StringTools.lpad(str,char,length);
		break;
	default:
		str = StringTools.rpad(str,char,length);
	}
	return str;
};
var djNode_KeycodeID = $hxEnums["djNode.KeycodeID"] = { __ename__ : true, __constructs__ : ["up","down","left","right","home","insert","delete","end","pageup","pagedown","backsp","tab","enter","space","esc","ctrlC","acute","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","other"]
	,up: {_hx_index:0,__enum__:"djNode.KeycodeID",toString:$estr}
	,down: {_hx_index:1,__enum__:"djNode.KeycodeID",toString:$estr}
	,left: {_hx_index:2,__enum__:"djNode.KeycodeID",toString:$estr}
	,right: {_hx_index:3,__enum__:"djNode.KeycodeID",toString:$estr}
	,home: {_hx_index:4,__enum__:"djNode.KeycodeID",toString:$estr}
	,insert: {_hx_index:5,__enum__:"djNode.KeycodeID",toString:$estr}
	,'delete': {_hx_index:6,__enum__:"djNode.KeycodeID",toString:$estr}
	,end: {_hx_index:7,__enum__:"djNode.KeycodeID",toString:$estr}
	,pageup: {_hx_index:8,__enum__:"djNode.KeycodeID",toString:$estr}
	,pagedown: {_hx_index:9,__enum__:"djNode.KeycodeID",toString:$estr}
	,backsp: {_hx_index:10,__enum__:"djNode.KeycodeID",toString:$estr}
	,tab: {_hx_index:11,__enum__:"djNode.KeycodeID",toString:$estr}
	,enter: {_hx_index:12,__enum__:"djNode.KeycodeID",toString:$estr}
	,space: {_hx_index:13,__enum__:"djNode.KeycodeID",toString:$estr}
	,esc: {_hx_index:14,__enum__:"djNode.KeycodeID",toString:$estr}
	,ctrlC: {_hx_index:15,__enum__:"djNode.KeycodeID",toString:$estr}
	,acute: {_hx_index:16,__enum__:"djNode.KeycodeID",toString:$estr}
	,F1: {_hx_index:17,__enum__:"djNode.KeycodeID",toString:$estr}
	,F2: {_hx_index:18,__enum__:"djNode.KeycodeID",toString:$estr}
	,F3: {_hx_index:19,__enum__:"djNode.KeycodeID",toString:$estr}
	,F4: {_hx_index:20,__enum__:"djNode.KeycodeID",toString:$estr}
	,F5: {_hx_index:21,__enum__:"djNode.KeycodeID",toString:$estr}
	,F6: {_hx_index:22,__enum__:"djNode.KeycodeID",toString:$estr}
	,F7: {_hx_index:23,__enum__:"djNode.KeycodeID",toString:$estr}
	,F8: {_hx_index:24,__enum__:"djNode.KeycodeID",toString:$estr}
	,F9: {_hx_index:25,__enum__:"djNode.KeycodeID",toString:$estr}
	,F10: {_hx_index:26,__enum__:"djNode.KeycodeID",toString:$estr}
	,F11: {_hx_index:27,__enum__:"djNode.KeycodeID",toString:$estr}
	,F12: {_hx_index:28,__enum__:"djNode.KeycodeID",toString:$estr}
	,other: {_hx_index:29,__enum__:"djNode.KeycodeID",toString:$estr}
};
var djNode_Keycode = function() { };
djNode_Keycode.__name__ = true;
djNode_Keycode.toKeyCodeID = function(key) {
	if(HxOverrides.cca(key,1) == null) {
		switch(HxOverrides.cca(key,0)) {
		case 3:
			return djNode_KeycodeID.ctrlC;
		case 8:
			return djNode_KeycodeID.backsp;
		case 9:
			return djNode_KeycodeID.tab;
		case 13:
			return djNode_KeycodeID.enter;
		case 27:
			return djNode_KeycodeID.esc;
		case 32:
			return djNode_KeycodeID.space;
		case 96:
			return djNode_KeycodeID.acute;
		case 127:
			return djNode_KeycodeID.backsp;
		}
	} else if(HxOverrides.cca(key,0) == 27 && HxOverrides.cca(key,1) == 91) {
		switch(HxOverrides.cca(key,2)) {
		case 49:
			switch(HxOverrides.cca(key,3)) {
			case 55:
				return djNode_KeycodeID.F6;
			case 56:
				return djNode_KeycodeID.F7;
			case 57:
				return djNode_KeycodeID.F8;
			case 126:
				return djNode_KeycodeID.home;
			}
			break;
		case 50:
			switch(HxOverrides.cca(key,3)) {
			case 48:
				return djNode_KeycodeID.F9;
			case 49:
				return djNode_KeycodeID.F10;
			case 51:
				return djNode_KeycodeID.F11;
			case 52:
				return djNode_KeycodeID.F12;
			case 126:
				return djNode_KeycodeID.insert;
			}
			break;
		case 51:
			return djNode_KeycodeID.delete;
		case 52:
			return djNode_KeycodeID.end;
		case 53:
			return djNode_KeycodeID.pageup;
		case 54:
			return djNode_KeycodeID.pagedown;
		case 65:
			return djNode_KeycodeID.up;
		case 66:
			return djNode_KeycodeID.down;
		case 67:
			return djNode_KeycodeID.right;
		case 68:
			return djNode_KeycodeID.left;
		case 91:
			switch(HxOverrides.cca(key,3)) {
			case 65:
				return djNode_KeycodeID.F1;
			case 66:
				return djNode_KeycodeID.F2;
			case 67:
				return djNode_KeycodeID.F3;
			case 68:
				return djNode_KeycodeID.F4;
			case 69:
				return djNode_KeycodeID.F5;
			}
			break;
		}
	}
	return null;
};
var djNode_Keyboard = function() { };
djNode_Keyboard.__name__ = true;
djNode_Keyboard.startCapture = function(realtime,callback) {
	if(realtime == null) {
		realtime = true;
	}
	djNode_Keyboard.stop();
	if(callback != null) {
		djNode_Keyboard.onData = callback;
	}
	djNode_Keyboard.stdin = process.stdin;
	djNode_Keyboard.stdin.setRawMode(realtime);
	djNode_Keyboard.stdin.setEncoding("utf8");
	djNode_Keyboard.stdin.on("data",djNode_Keyboard.onKeyData);
	djNode_Keyboard.stdin.resume();
};
djNode_Keyboard.onKeyData = function(data) {
	if(djNode_Keyboard.FLAG_CAN_BREAK && data == djNode_Keycode.CTRLC) {
		djNode_Keyboard.stop();
		if(djNode_Keyboard.onBreak != null) {
			djNode_Keyboard.onBreak();
		}
		djNode_Keyboard.onBreak = null;
		return;
	}
	if(djNode_Keyboard.onData != null) {
		djNode_Keyboard.onData(data);
	}
};
djNode_Keyboard.stop = function() {
	if(djNode_Keyboard.stdin == null) {
		return;
	}
	djNode_Keyboard.stdin.pause();
	djNode_Keyboard.stdin.setRawMode(false);
	djNode_Keyboard.stdin.removeAllListeners("data");
};
djNode_Keyboard.flush = function() {
	if(djNode_Keyboard.stdin == null) {
		return;
	}
	djNode_Keyboard.stdin.pause();
	djNode_Keyboard.stdin.resume();
};
djNode_Keyboard.readOnceSync = function() {
	var SIZE = 512;
	var b = js_node_buffer_Buffer.alloc(SIZE);
	var bytesin = 0;
	bytesin = 0;
	try {
		bytesin = js_node_Fs.readSync(process.stdin.fd,b,0,SIZE,null);
	} catch( _g ) {
		var e = haxe_Exception.caught(_g).unwrap();
		throw haxe_Exception.thrown(e);
	}
	return b.toString("utf8",0,bytesin - 2);
};
var djNode_TColor = $hxEnums["djNode.TColor"] = { __ename__ : true, __constructs__ : ["black","white","gray","red","green","blue","yellow","cyan","magenta","darkgray","darkred","darkgreen","darkblue","darkyellow","darkcyan","darkmagenta"]
	,black: {_hx_index:0,__enum__:"djNode.TColor",toString:$estr}
	,white: {_hx_index:1,__enum__:"djNode.TColor",toString:$estr}
	,gray: {_hx_index:2,__enum__:"djNode.TColor",toString:$estr}
	,red: {_hx_index:3,__enum__:"djNode.TColor",toString:$estr}
	,green: {_hx_index:4,__enum__:"djNode.TColor",toString:$estr}
	,blue: {_hx_index:5,__enum__:"djNode.TColor",toString:$estr}
	,yellow: {_hx_index:6,__enum__:"djNode.TColor",toString:$estr}
	,cyan: {_hx_index:7,__enum__:"djNode.TColor",toString:$estr}
	,magenta: {_hx_index:8,__enum__:"djNode.TColor",toString:$estr}
	,darkgray: {_hx_index:9,__enum__:"djNode.TColor",toString:$estr}
	,darkred: {_hx_index:10,__enum__:"djNode.TColor",toString:$estr}
	,darkgreen: {_hx_index:11,__enum__:"djNode.TColor",toString:$estr}
	,darkblue: {_hx_index:12,__enum__:"djNode.TColor",toString:$estr}
	,darkyellow: {_hx_index:13,__enum__:"djNode.TColor",toString:$estr}
	,darkcyan: {_hx_index:14,__enum__:"djNode.TColor",toString:$estr}
	,darkmagenta: {_hx_index:15,__enum__:"djNode.TColor",toString:$estr}
};
var djNode_Terminal = function() {
	this.PARSED_NOTAG = "";
	this.ENABLE_NOTAG = false;
	var _g = new haxe_ds_EnumValueMap();
	_g.set(djNode_TColor.darkgray,"\x1B[90m");
	_g.set(djNode_TColor.red,"\x1B[91m");
	_g.set(djNode_TColor.green,"\x1B[92m");
	_g.set(djNode_TColor.yellow,"\x1B[93m");
	_g.set(djNode_TColor.blue,"\x1B[94m");
	_g.set(djNode_TColor.magenta,"\x1B[95m");
	_g.set(djNode_TColor.cyan,"\x1B[96m");
	_g.set(djNode_TColor.white,"\x1B[97m");
	_g.set(djNode_TColor.black,"\x1B[30m");
	_g.set(djNode_TColor.darkred,"\x1B[31m");
	_g.set(djNode_TColor.darkgreen,"\x1B[32m");
	_g.set(djNode_TColor.darkyellow,"\x1B[33m");
	_g.set(djNode_TColor.darkblue,"\x1B[34m");
	_g.set(djNode_TColor.darkmagenta,"\x1B[35m");
	_g.set(djNode_TColor.darkcyan,"\x1B[36m");
	_g.set(djNode_TColor.gray,"\x1B[37m");
	this.COLORS_FG = _g;
	var _g = new haxe_ds_EnumValueMap();
	_g.set(djNode_TColor.darkgray,"\x1B[100m");
	_g.set(djNode_TColor.red,"\x1B[101m");
	_g.set(djNode_TColor.green,"\x1B[102m");
	_g.set(djNode_TColor.yellow,"\x1B[103m");
	_g.set(djNode_TColor.blue,"\x1B[104m");
	_g.set(djNode_TColor.magenta,"\x1B[105m");
	_g.set(djNode_TColor.cyan,"\x1B[106m");
	_g.set(djNode_TColor.white,"\x1B[107m");
	_g.set(djNode_TColor.black,"\x1B[40m");
	_g.set(djNode_TColor.darkred,"\x1B[41m");
	_g.set(djNode_TColor.darkgreen,"\x1B[42m");
	_g.set(djNode_TColor.darkyellow,"\x1B[43m");
	_g.set(djNode_TColor.darkblue,"\x1B[44m");
	_g.set(djNode_TColor.darkmagenta,"\x1B[45m");
	_g.set(djNode_TColor.darkcyan,"\x1B[46m");
	_g.set(djNode_TColor.gray,"\x1B[47m");
	this.COLORS_BG = _g;
};
djNode_Terminal.__name__ = true;
djNode_Terminal.prototype = {
	fg: function(col) {
		if(col == null) {
			process.stdout.write("\x1B[39m");
			return this;
		}
		var str = this.COLORS_FG.get(col);
		process.stdout.write(str);
		return this;
	}
	,bold: function() {
		process.stdout.write("\x1B[1m");
		return this;
	}
	,cursorShow: function() {
		process.stdout.write("\x1B[?25h");
		return this;
	}
	,ptag: function(s) {
		var str = this.parseTags(s);
		process.stdout.write(str);
		return this;
	}
	,parseTags: function(str) {
		var _gthis = this;
		var res = new EReg("<(\\S+?)>","g").map(str,function(reg) {
			var src = reg.matched(1);
			var prop = src.split(",");
			var ret = "";
			var _g = 0;
			while(_g < prop.length) {
				var p = prop[_g];
				++_g;
				var ret1;
				switch(p) {
				case "!":
					ret1 = "\x1B[0m";
					break;
				case "!bg":
					ret1 = "\x1B[49m";
					break;
				case "!blink":
					ret1 = "\x1B[25m";
					break;
				case "!bold":
					ret1 = "\x1B[21m";
					break;
				case "!dim":
					ret1 = "\x1B[22m";
					break;
				case "!fg":
					ret1 = "\x1B[39m";
					break;
				case "!underl":
					ret1 = "\x1B[24m";
					break;
				case "blink":
					ret1 = "\x1B[5m";
					break;
				case "bold":
					ret1 = "\x1B[1m";
					break;
				case "cr":
					ret1 = "\x1B[u";
					break;
				case "cs":
					ret1 = "\x1B[s";
					break;
				case "dim":
					ret1 = "\x1B[2m";
					break;
				case "underl":
					ret1 = "\x1B[4m";
					break;
				default:
					if(p.indexOf(":") == 0) {
						try {
							ret1 = _gthis.COLORS_BG.get(Type.createEnum(djNode_TColor,p.split(":")[1],null));
						} catch( _g1 ) {
							throw haxe_Exception.thrown("Tag Error: Color does not exist in `" + src + "`");
						}
					} else {
						try {
							ret1 = _gthis.COLORS_FG.get(Type.createEnum(djNode_TColor,p,null));
						} catch( _g2 ) {
							ret1 = reg.matched(0);
						}
					}
				}
				ret += ret1;
			}
			return ret;
		});
		if(this.ENABLE_NOTAG) {
			this.PARSED_NOTAG = new EReg("<(\\S+?)>","g").map(str,function(reg) {
				return "";
			});
		}
		return res;
	}
};
var djNode_app_PismoMount = function() { };
djNode_app_PismoMount.__name__ = true;
djNode_app_PismoMount.mount = function(p,drive) {
	if(drive != null) {
		var res = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " mount -i -m " + drive + " \"" + p + "\"");
		return "" + drive + ":\\";
	}
	var res0 = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " mount -i \"" + p + "\"");
	var res1 = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " list \"" + p + "\"");
	var reg = new EReg(".*(?:\\.zip|\\.pfo|\\.cfs) (.*)","ig");
	if(reg.match(res1)) {
		return reg.matched(1);
	} else {
		return null;
	}
};
djNode_app_PismoMount.unmount = function(p) {
	try {
		var s = p == null ? "" : "\"" + p + "\"";
		var a = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " unmount " + s);
		if(a != null) {
			return true;
		}
	} catch( _g ) {
	}
	return false;
};
var djNode_tools_FileTool = function() { };
djNode_tools_FileTool.__name__ = true;
djNode_tools_FileTool.getFiles = function(path,deep,ext) {
	if(deep == null) {
		deep = false;
	}
	var FIN = js_node_Fs.readdirSync(path);
	var FOUT = [];
	var _g = 0;
	while(_g < FIN.length) {
		var f = FIN[_g];
		++_g;
		var fullfile = js_node_Path.join(path,f);
		var stat;
		try {
			stat = js_node_Fs.statSync(fullfile);
		} catch( _g1 ) {
			continue;
		}
		if(stat.isFile()) {
			if(ext != null && ext.indexOf(js_node_Path.extname(f).toLowerCase()) < 0) {
				continue;
			}
			FOUT.push(fullfile);
		} else if(stat.isDirectory()) {
			if(deep) {
				FOUT = FOUT.concat(djNode_tools_FileTool.getFiles(fullfile,deep,ext));
			}
		} else {
			continue;
		}
	}
	return FOUT;
};
djNode_tools_FileTool.getFileListFromWildcard = function(path) {
	var fileList = [];
	var basePath = js_node_Path.dirname(path);
	var extToGet = djNode_tools_FileTool.getFileExt(path);
	var baseToGet;
	var exp = new EReg("(\\S*)\\.","");
	if(exp.match(js_node_Path.basename(path))) {
		baseToGet = exp.matched(1);
		if(baseToGet.length > 1 && baseToGet.indexOf("*") > 0) {
			throw haxe_Exception.thrown("Advanced search is currently unsupported, use basic [*.*] or [*.ext]");
		}
	} else {
		baseToGet = "*";
	}
	var allfiles = js_node_Fs.readdirSync(js_node_Path.normalize(basePath));
	var stats;
	var _g = 0;
	while(_g < allfiles.length) {
		var i = allfiles[_g];
		++_g;
		try {
			stats = js_node_Fs.statSync(js_node_Path.join(basePath,i));
		} catch( _g1 ) {
			continue;
		}
		if(stats.isFile()) {
			if(baseToGet != "*") {
				if(exp.match(i)) {
					if(baseToGet != exp.matched(1)) {
						continue;
					}
				} else {
					continue;
				}
			}
			if(extToGet == ".*") {
				fileList.push(js_node_Path.join(basePath,i));
				continue;
			}
			if(extToGet == js_node_Path.extname(i).toLowerCase()) {
				fileList.push(js_node_Path.join(basePath,i));
				continue;
			}
		}
	}
	return fileList;
};
djNode_tools_FileTool.getFileExt = function(file) {
	return js_node_Path.extname(file).toLowerCase();
};
var djNode_tools_LOG = function() { };
djNode_tools_LOG.__name__ = true;
djNode_tools_LOG.init = function() {
	if(djNode_tools_LOG._isInited) {
		return;
	}
	djNode_tools_LOG._isInited = true;
	djNode_tools_LOG.messages = [];
};
djNode_tools_LOG.end = function() {
	if(djNode_tools_LOG.flag_socket_log) {
		djNode_tools_LOG.io.close();
	}
};
djNode_tools_LOG.pipeTrace = function(produceStdout) {
	if(produceStdout == null) {
		produceStdout = false;
	}
	djNode_tools_LOG.FLAG_STDOUT = produceStdout;
	haxe_Log.trace = function(msg,pos) {
		djNode_tools_LOG.log(msg,1,pos);
		if(pos != null && pos.customParams != null) {
			var _g = 0;
			var _g1 = pos.customParams;
			while(_g < _g1.length) {
				var v = _g1[_g];
				++_g;
				djNode_tools_LOG.log(v,1,pos);
			}
		}
	};
};
djNode_tools_LOG.log = function(obj,level,d) {
	if(level == null) {
		level = 1;
	}
	if(level < djNode_tools_LOG.logLevel) {
		return;
	}
	var logmsg = { pos : null, log : Std.string(obj), level : level};
	if(djNode_tools_LOG.BUFFER_SIZE > 0 && djNode_tools_LOG.messages.length >= djNode_tools_LOG.BUFFER_SIZE) {
		djNode_tools_LOG.messages.shift();
	}
	djNode_tools_LOG.messages.push(logmsg);
	if(djNode_tools_LOG.flag_socket_log) {
		djNode_tools_LOG.io.sockets.emit("logText",{ data : logmsg.log, pos : logmsg.pos, level : logmsg.level});
	}
	if(djNode_tools_LOG.logFile != null) {
		djNode_tools_LOG.push_File(logmsg);
	}
	if(djNode_tools_LOG.onLog != null) {
		djNode_tools_LOG.onLog(logmsg);
	}
	if(djNode_tools_LOG.FLAG_STDOUT) {
		var _this = djNode_BaseApp.TERMINAL;
		var str = logmsg.log;
		process.stdout.write(str + "\n");
	}
};
djNode_tools_LOG.push_File = function(log) {
	var m = "";
	if(djNode_tools_LOG.FLAG_SHOW_MESSAGE_TYPE) {
		m += djNode_tools_LOG.messageTypes[log.level] + " ";
	}
	m += log.log + "\n";
	try {
		js_node_Fs.appendFileSync(djNode_tools_LOG.logFile,m,"utf8");
	} catch( _g ) {
		if(((haxe_Exception.caught(_g).unwrap()) instanceof Error)) {
			djNode_BaseApp.TERMINAL.ptag("<red> - NO SPACE LEFT FOR THE LOG FILE - <!>\n");
			process.exit(1);
		} else {
			throw _g;
		}
	}
};
var djNode_utils_CLIApp = function() { };
djNode_utils_CLIApp.__name__ = true;
djNode_utils_CLIApp.quickExecS = function(path,cwd) {
	try {
		if(!djNode_utils_CLIApp.FLAG_LOG_QUIET) {
			djNode_tools_LOG.log("ExecSync : " + path + " | cwd : " + (cwd == null ? process.cwd() : cwd));
		}
		return js_node_ChildProcess.execSync(path,{ cwd : cwd, stdio : ["ignore","pipe","ignore"]});
	} catch( _g ) {
		return null;
	}
};
djNode_utils_CLIApp.checkRun = function(execStr) {
	try {
		var pr = js_node_ChildProcess.execSync(execStr,{ timeout : 10000, stdio : "ignore"});
		return true;
	} catch( _g ) {
		return false;
	}
};
var djNode_utils_Print2 = function(printMode) {
	if(printMode == null) {
		printMode = 0;
	}
	this.pmode = 0;
	this.lpad = 0;
	this.T = djNode_BaseApp.TERMINAL;
	if(printMode > 0) {
		this.buffer = [];
		this.T.ENABLE_NOTAG = true;
	}
	this.pmode = printMode;
};
djNode_utils_Print2.__name__ = true;
djNode_utils_Print2.prototype = {
	_prtl: function(s) {
		if(this.pmode < 2) {
			var _this = this.T;
			process.stdout.write(s + "\n");
		}
		if(this.pmode > 0) {
			this.buffer.push(s);
		}
	}
	,H: function(text,size) {
		if(size == null) {
			size = 0;
		}
		var s = djNode_utils_Print2.H_STYLES[size];
		this.lpad = s.pad0;
		this.ptem(s.templ,text);
		if(s.line != null) {
			var r = s.line.split(":");
			var l = Std.parseInt(r[0]);
			if(l == 1) {
				l = this.T.PARSED_NOTAG.length;
			}
			if(l > 0) {
				this.T.fg(Type.createEnum(djNode_TColor,r[1],null));
				this.line(l);
				var _this = this.T;
				process.stdout.write("\x1B[39m");
			}
		}
		this.lpad = s.pad1;
		return this;
	}
	,p: function(text) {
		if(this.lpad > 0) {
			text = djA_StrT.rep(this.lpad," ") + text;
		}
		var t2 = this.T.parseTags(text);
		if(this.pmode < 2) {
			var _this = this.T;
			process.stdout.write(t2 + "\n");
		}
		if(this.pmode > 0) {
			this.buffer.push(this.T.PARSED_NOTAG);
		}
		return this;
	}
	,br: function() {
		this._prtl("");
		return this;
	}
	,line: function(len) {
		if(len == null) {
			len = 40;
		}
		this._prtl(djA_StrT.rep(this.lpad," ") + djA_StrT.rep(len,"─"));
		return this;
	}
	,ptem: function(tem,t1,t2,t3) {
		return this.p(this.parseTempl(tem,t1,t2,t3));
	}
	,parseTempl: function(tem,t1,t2,t3) {
		var r = new EReg("\\{(\\d+):?(\\d+)?\\}","g");
		return r.map(tem,function(r1) {
			var m = r.matched(1);
			var part;
			var _g = Std.parseInt(m);
			if(_g == null) {
				throw haxe_Exception.thrown("Templates support up to three(3) capture groups");
			} else {
				switch(_g) {
				case 1:
					part = t1;
					break;
				case 2:
					part = t2;
					break;
				case 3:
					part = t3;
					break;
				default:
					throw haxe_Exception.thrown("Templates support up to three(3) capture groups");
				}
			}
			if(r1.matched(2) != null) {
				part = djA_StrT.padString(part,Std.parseInt(r1.matched(2)));
			}
			return part;
		});
	}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__properties__: {get_native:"get_native"}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_ds_BalancedTree = function() {
};
haxe_ds_BalancedTree.__name__ = true;
haxe_ds_BalancedTree.prototype = {
	set: function(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	,get: function(key) {
		var node = this.root;
		while(node != null) {
			var c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	,setLoop: function(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		var c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			var nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			var nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	,balance: function(l,k,v,r) {
		var hl = l == null ? 0 : l._height;
		var hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			var _this = l.left;
			var _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			var _this = r.right;
			var _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	,compare: function(k1,k2) {
		return Reflect.compare(k1,k2);
	}
};
var haxe_ds_TreeNode = function(l,k,v,r,h) {
	if(h == null) {
		h = -1;
	}
	this.left = l;
	this.key = k;
	this.value = v;
	this.right = r;
	if(h == -1) {
		var tmp;
		var _this = this.left;
		var _this1 = this.right;
		if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
			var _this = this.left;
			tmp = _this == null ? 0 : _this._height;
		} else {
			var _this = this.right;
			tmp = _this == null ? 0 : _this._height;
		}
		this._height = tmp + 1;
	} else {
		this._height = h;
	}
};
haxe_ds_TreeNode.__name__ = true;
var haxe_ds_EnumValueMap = function() {
	haxe_ds_BalancedTree.call(this);
};
haxe_ds_EnumValueMap.__name__ = true;
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
haxe_ds_EnumValueMap.prototype = $extend(haxe_ds_BalancedTree.prototype,{
	compare: function(k1,k2) {
		var d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		var p1 = Type.enumParameters(k1);
		var p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	,compareArgs: function(a1,a2) {
		var ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		var _g = 0;
		var _g1 = a1.length;
		while(_g < _g1) {
			var i = _g++;
			var d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	,compareArg: function(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_KeyValue = {};
js_node_KeyValue.__properties__ = {get_value:"get_value",get_key:"get_key"};
js_node_KeyValue.get_key = function(this1) {
	return this1[0];
};
js_node_KeyValue.get_value = function(this1) {
	return this1[1];
};
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_stream_WritableNewOptionsAdapter = {};
js_node_stream_WritableNewOptionsAdapter.from = function(options) {
	if(!Object.prototype.hasOwnProperty.call(options,"final")) {
		Object.defineProperty(options,"final",{ get : function() {
			return options.final_;
		}});
	}
	return options;
};
var js_node_url_URLSearchParamsEntry = {};
js_node_url_URLSearchParamsEntry.__properties__ = {get_value:"get_value",get_name:"get_name"};
js_node_url_URLSearchParamsEntry._new = function(name,value) {
	var this1 = [name,value];
	return this1;
};
js_node_url_URLSearchParamsEntry.get_name = function(this1) {
	return this1[0];
};
js_node_url_URLSearchParamsEntry.get_value = function(this1) {
	return this1[1];
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
djNode_BaseApp.VERSION = "0.6.1";
djNode_BaseApp.LINE_LEN = 40;
Main.EXT_0 = [".bin"];
Main.EXT_1 = [".zip",".pfo",".cfs"];
djA_StrT.OVERFLOW_SMBL = "-";
djNode_Keycode.CTRLC = "\x03";
djNode_Keycode.ESC = "\x1B";
djNode_Keycode.UP = "\x1B[A";
djNode_Keycode.DOWN = "\x1B[B";
djNode_Keycode.LEFT = "\x1B[C";
djNode_Keycode.RIGHT = "\x1B[D";
djNode_Keycode.BACKSP = "\x08";
djNode_Keycode.TAB = "\t";
djNode_Keycode.ENTER = "\r";
djNode_Keycode.DELETE = "";
djNode_Keyboard.FLAG_CAN_BREAK = true;
djNode_app_PismoMount.EXE = "pfm.exe";
djNode_tools_LOG.messageTypes = ["DEBUG","INFO","WARN","ERROR","FATAL"];
djNode_tools_LOG._isInited = false;
djNode_tools_LOG.logLevel = 0;
djNode_tools_LOG.flag_socket_log = false;
djNode_tools_LOG.FLAG_SHOW_MESSAGE_TYPE = false;
djNode_tools_LOG.FLAG_STDOUT = false;
djNode_tools_LOG.BUFFER_SIZE = 8000;
djNode_utils_CLIApp.FLAG_LOG_QUIET = true;
djNode_utils_Print2.H_STYLES = [{ templ : "<cyan>>><bold,white,:darkblue> {1} <!>", pad0 : 1, pad1 : 4, line : null},{ templ : "<:blue,black>><!> <blue>{1}<!>", pad0 : 4, pad1 : 6, line : null}];
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
